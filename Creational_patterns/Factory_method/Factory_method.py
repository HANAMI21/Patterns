from __future__ import annotations

from abc import ABC, abstractmethod


class Cook(ABC):
    """
    Класс Повар объявляет фабричный метод, который должен возвращать объект
    класса Блюдо. Подклассы Повара предоставляют реализацию этого
    метода для конкретных Блюд.
    """

    @abstractmethod
    def cook_dish(self):
        """
        Релизация фабричного метода организована по умолчанию.
        """
        pass

    def serve_dish(self) -> str:
        """
        Данная функция отвечает за подачу блюда посетителю
        с изложением краткой информации про блюдо
        """

        # Вызываем фабричный метод, чтобы получить объект-Блюдо.
        dish = self.cook_dish()

        # Далее, работаем с этим блюдом.
        result = f"Блюдо которое готовит этот повар:\n{dish.info()}"

        return result


class PizzaCook(Cook):
    """
    Обратите внимание, что сигнатура метода по-прежнему использует тип
    абстрактного продукта, хотя фактически из метода возвращается конкретный
    продукт. Таким образом, Создатель может оставаться независимым от конкретных
    классов продуктов.
    """

    def cook_dish(self) -> Dish:
        return Pizza()


class SushiCook(Cook):
    def cook_dish(self) -> Dish:
        return Sushi()


class Dish(ABC):
    """
    Интерфейс Блюдо объявляет метод, который должны выполнять все
    конкретные продукты. В моем случае это вывод информации о конкретном блюде.
    """

    @abstractmethod
    def info(self) -> str:
        pass


"""
Конкретные Продукты предоставляют различные реализации интерфейса Блюдо.
"""


class Pizza(Dish):
    def info(self) -> str:
        return "Пи́цца — традиционное итальянское блюдо изначально в виде круглой дрожжевой лепёшки, выпекаемой с " \
               "уложенной сверху начинкой из томатного соуса и сыра."


class Sushi(Dish):
    def info(self) -> str:
        return "Суши — блюдо традиционной японской кухни, приготовленное из риса с уксусной приправой и различных " \
               "морепродуктов, а также других ингредиентов."


def client_code(cook: Cook) -> None:
    """
    Программа работает с экземплярами классов через общий интерфейс Повар
    и Блюдо. При этом никак не зависит от конкретных классов, которые создаются
    фабричным методом.
    """

    print(cook.serve_dish())


if __name__ == "__main__":
    client_code(PizzaCook())
    print("\n")

    client_code(SushiCook())
